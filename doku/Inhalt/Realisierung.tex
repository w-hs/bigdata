\section{Implementierung}

Die Implementierung erfolgt iterativ. D.h. wir entwickeln unterschiedliche ggf. aufeinander aufbauende Lösungen
und versuchen uns mit jedem Versuch zu verbessern. Unseren Fortschritt messen wir, indem wir in jeder
Iteration ein einreichbares Ergebnis erzeugen. Die Bewertung erfolgt somit über einen internen Algorithmus
von Kaggle.

\subsection{Iteration 0}

Als Erstes wollen wir eine Grundlage zur Bewertung folgender Versuche schaffen und das Einreichen einer
Lösung bei Kaggle üben. Dazu erzeugen wir eine Datei, die jedem Kunden die Kaufwahrscheinlichkeit 0\%
zuordnet. Hierzu verwenden wir eine rudimentäre Hive-Abfrage.

\begin{lstlisting}[language=SQL]
SELECT DISTINCT(h.id), 0.0 AS repeatProbability 
FROM test_history h
\end{lstlisting}

Die Bewertung von Kaggle sieht wie folgt aus:

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 932 & 0.50000  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 1}

Im nächsten Schritt wollen wir die den ersten "`Prior Category Benchmark"' von Kaggle implementieren.
Dieser Benchmark ordnet Kunden, die bereits ein Produkt der Angebotskategorie gekauft haben, die
Wiederkaufwahrscheinlichkeit 1 zu. Allen anderen Kunden wird die Wahrscheinlichkeit 0 zugeordnet.

Wir bestimmen die Kunden mit einer Wahrscheinlichkeit von 1 über folgende Hive-Abfrage:
\begin{lstlisting}[language=SQL]
SELECT DISTINCT h.id, 1.0 AS repeatProbability
  FROM test_history h INNER JOIN offers o ON (h.offer = o.offer)
INNER JOIN transactions t ON (t.id = h.id)
WHERE t.category = o.category
\end{lstlisting}

Um das Ergebnis bei Kaggle einzureichen, fehlen noch die Kunden mit einer Wahrscheinlichkeit von 0.
Um diese hinzuzufügen wurde ein Python-Skript entwickelt, dass eine unvollständige Einreichung
um die fehlenden Einträge erweitert. Für diese Kunden wird eine Wahrscheinlichkeit von 0 eingetragen.
Diese Skript (s. Anhang \ref{code:complete-submission}) kann in weiteren Iterationen verwendet werden,
um sicher zu stellen, dass das Ergebnis vollständig ist und die Überprüfung von Kaggle übersteht. 

Die Bewertung von Kaggle ergibt wie erwartet:

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 747 & 0.52000  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 2}

In Iteration 1 haben wir den Benchmark mit der niedrigsten Bewertung implementiert. Jetzt wollen wir 
den besten Benchmark umsetzen. Der "`Prior (Brand \& Company \& Category) Benchmark"' ist sehr ähnlich
zu dem ersten Benchmark. Wir ordnen jedem Kunden, der schon einmal ein Produkt der Angebotsmarke,
des Angebotsunternehmens und der Angebotskategorie gekauft hat, eine 1 zu. Den anderen Kunden wird
eine Wahrscheinlichkeit von 0 zugeordnet.

\begin{lstlisting}[language=SQL]
SELECT DISTINCT h.id, 1.0 AS repeatProbability
  FROM test_history h INNER JOIN offers o ON (h.offer = o.offer)
INNER JOIN transactions t ON (t.id = h.id)
WHERE t.category = o.category
  AND t.company = o.company
  AND t.brand = o.brand
\end{lstlisting}

Bevor wir das Ergebnis einreichen, verwenden wir das Skript zum Vervollständigen aus Iteration 1.

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 627 & 0.56425  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 3}

Feature-Engineering: Nur positive Features

\subsection{Iteration 4}

Feature-Engineerung: Jetzt auch negative Features

\subsection{Amazon Web Services}
\subsection{Iteration 2}
