\section{Implementierung}

Die Implementierung erfolgt iterativ. D.h. wir entwickeln unterschiedliche ggf. aufeinander aufbauende Lösungen
und versuchen uns mit jedem Versuch zu verbessern. Unseren Fortschritt messen wir, indem wir in jeder
Iteration ein einreichbares Ergebnis erzeugen. Die Bewertung erfolgt somit über einen internen Algorithmus
von Kaggle.

\subsection{Iteration 0}

Als Erstes wollen wir eine Grundlage zur Bewertung folgender Versuche schaffen und das Einreichen einer
Lösung bei Kaggle üben. Dazu erzeugen wir eine Datei, die jedem Kunden die Kaufwahrscheinlichkeit 0\%
zuordnet. Hierzu verwenden wir eine rudimentäre Hive-Abfrage.

\begin{lstlisting}[language=SQL]
SELECT DISTINCT(h.id), 0.0 AS repeatProbability 
FROM test_history h
\end{lstlisting}

Die Bewertung von Kaggle sieht wie folgt aus:

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 932 & 0.50000  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 1}

Im nächsten Schritt wollen wir den ersten "`Prior Category Benchmark"' von Kaggle implementieren.
Dieser Benchmark ordnet Kunden, die bereits ein Produkt der Angebotskategorie gekauft haben, die
Wiederkaufwahrscheinlichkeit 1 zu. Allen anderen Kunden wird die Wahrscheinlichkeit 0 zugeordnet.

Wir bestimmen die Kunden mit einer Wahrscheinlichkeit von 1 über folgende Hive-Abfrage:
\begin{lstlisting}[language=SQL]
SELECT DISTINCT h.id, 1.0 AS repeatProbability
FROM test_history h INNER JOIN offers o ON (h.offer = o.offer)
INNER JOIN transactions t ON (t.id = h.id)
WHERE t.category = o.category
\end{lstlisting}

Um das Ergebnis bei Kaggle einzureichen, fehlen noch die Kunden mit einer Wahrscheinlichkeit von 0.
Um diese hinzuzufügen wurde ein Python-Skript entwickelt, dass eine unvollständige Einreichung
um die fehlenden Einträge erweitert. Für diese Kunden wird eine Wahrscheinlichkeit von 0 eingetragen.
Dieses Skript (s. Anhang \ref{code:complete-submission}) kann in weiteren Iterationen verwendet werden,
um sicher zu stellen, dass das Ergebnis vollständig ist und die Überprüfung von Kaggle übersteht. 

Die Bewertung von Kaggle ergibt wie erwartet:

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 747 & 0.52000  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 2}

In Iteration 1 haben wir den Benchmark mit der niedrigsten Bewertung implementiert. Jetzt wollen wir 
den besten Benchmark umsetzen. Der "`Prior (Brand \& Company \& Category) Benchmark"' ist sehr ähnlich
zu dem ersten Benchmark. Wir ordnen jedem Kunden, der schon einmal ein Produkt der Angebotsmarke,
des Angebotsunternehmens und der Angebotskategorie gekauft hat, eine 1 zu. Den anderen Kunden wird
eine Wahrscheinlichkeit von 0 zugeordnet.

\begin{lstlisting}[language=SQL]
SELECT DISTINCT h.id, 1.0 AS repeatProbability
FROM test_history h INNER JOIN offers o ON (h.offer = o.offer)
INNER JOIN transactions t ON (t.id = h.id)
WHERE t.category = o.category
  AND t.company = o.company
  AND t.brand = o.brand
\end{lstlisting}

Bevor wir das Ergebnis einreichen, verwenden wir das Skript zum Vervollständigen aus Iteration 1.

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 627 & 0.56425  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 3}

Feature-Engineering: Nur positive Features

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 499 & 0.58051  \\ 
	\hline 
\end{tabular}

\subsection{Iteration 4}

Feature-Engineerung: Jetzt auch negative Features

Ergänzung zu der Datei, die die Eingabe für Vorpal Wabbit erzeugt:
\begin{lstlisting}[language=Python]
# Negative Features erzeugen, wenn nichts gekauft wurde
if len(row['b_tx_count']) == 0:
	output += ' b_never:1'
if len(row['co_tx_count']) == 0:
	output += ' co_never:1'
if len(row['ca_tx_count']) == 0:
	output += ' ca_never:1'
\end{lstlisting}

\begin{tabular}{|c|c|}
	\hline \textbf{Platzierung} & \textbf{Bewertung} \\ 
	\hline 344 & 0.58786  \\ 
	\hline 
\end{tabular}

Besser als die im letzten Jahr: 452 0.58519

\subsection{Iteration 5}
	Ideen:
		Ausgangssituation: Es werden bisher nur Transaktionen berücksichtigt die in Beziehung zu Angeboten stehen. Die Transaktion muss entweder eine Marke, eine Category oder eine Company haben. Es werden also noch keine Daten von Käufen berücksichtigt, für die es keine Angebote gab oder gibt. Diese Daten sollen in diesem Iterationsschritt ebenfalls verwerten werden, wozu zunächst die folgenden Ansätze zusammengetragen wurden:
		
		- Zählen wie oft die ID eines Kunden eingekauft hat. Überschreitet der Wert einen Schwellwert ist die Wahrscheinlichkeit groß das er wiederkommt.
		
		- Für jeden Kunden den kompletten Umsatz pro Quartal beziehungsweise pro Jahr zu ermitteln. Es gibt also 2 Klassen - Leute die viel oder die wenig Geld ausgeben. Die Idee ist, dass Leute die viel Geld umsetzen weniger gut durch Gutscheine ansprechbar sind, als Leute die wenig zum Umsatz beitragen.  
		
		- Kunden die in regelmässigen Abständen einkaufen, kommen sehr wahrscheinlich wieder. Beispielsweise werden wöchentlich die Nahrungsvorräte auf dem Heimweg nach der Arbeit aufgefrischt. Das lässt sich über die ID des Kunden und über das Date Feld bestimmen.
		
		- Kunden die große Menge (purchasequantity) gekauft haben, kommen wahrscheinlich wieder. Sie benötigen keine Gutscheine, da der Preis so schon gut ist oder der Markt zum Einkauf gut gelegen ist. Realisierung: Was ist die Definition von viel? Erstellen eines Mittelwertes über die Spalte - jeder Wert der über dem Mittelwert liegt, gilt als viel.
	
\subsection{Amazon Web Services}

