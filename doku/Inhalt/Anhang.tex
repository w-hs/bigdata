\section{Hive-Abfragen}

\subsection{Kunden-Daten}
\begin{lstlisting}[language=SQL]
CREATE TABLE customers AS 
(
  SELECT te.id, te.offer, te.offerdate
    FROM test_history te
  UNION
  SELECT tr.id, tr.offer, tr.offerdate
    FROM train_history tr 
)
\end{lstlisting}

\subsection{Transaktionen gefiltert nach Marke, Unternehmen oder Kategorie}
\label{sql:filtered_tx}
\begin{lstlisting}[language=SQL]
-- Gefiltert nach Marke (brand)
CREATE TABLE filtered_tx_brand AS
  SELECT t.id, t.purchasequantity, t.purchaseamount, 
         (c.offerdate - t.date) AS daysbefore 
  FROM filtered_transactions t 
  INNER JOIN customers c ON (t.id = c.id)
  INNER JOIN offers o ON (c.offer = o.offer)
  WHERE o.brand = t.brand
  
-- Gefiltert nach Unternehmen (company)
CREATE TABLE filtered_tx_company AS
  SELECT t.id, t.purchasequantity, t.purchaseamount, 
         (h.offerdate - t.date) AS daysbefore 
  FROM filtered_transactions t 
  INNER JOIN test_history h ON (t.id = h.id)
  INNER JOIN offers o ON (h.offer = o.offer)
  WHERE o.company = t.company
  
-- Gefiltert nach Kategorie (category)
CREATE TABLE filtered_tx_category AS
  SELECT t.id, t.purchasequantity, t.purchaseamount, 
         (c.offerdate - t.date) AS daysbefore 
  FROM filtered_transactions t 
  INNER JOIN customers c ON (t.id = c.id)
  INNER JOIN offers o ON (c.offer = o.offer)
  WHERE o.category = t.category
\end{lstlisting}

\section{complete-submission.py}
\label{code:complete-submission}
\begin{lstlisting}[language=Python]
#!/usr/bin/env python

# Diese Skript vervollständigt eine Kaggle-Einreichung.
# Fehlenden Kunden wird eine Wahrscheinlichkeit von 0 
# zugeordnet.
# Die Datei sampleSubmissions.csv muss sich im aktuellen 
# Verzeichnis befinden

import sys

samplesFile = open('sampleSubmission.csv', 'r')
samplesFile.readline()
samples = { }
for line in samplesFile:
	id, prob = line.split(',', 1)
	samples[id] = prob

# Erste Zeile ignorieren
sys.stdin.readline()
# Und die geforderte Kopfzeile ausgeben
sys.stdout.write("id,repeatProbability\n")

for line in sys.stdin:
	id, prob = line.split(',', 1)
	if (id in samples):
		del samples[id]
	sys.stdout.write(id + ',' + prob)

	for id in samples:
		sys.stdout.write(id + ',' + samples[id])
\end{lstlisting}

\section{features-to-vw.py}
\label{code:features-to-vw}
\begin{lstlisting}[language=Python]
#!/usr/bin/env python

import sys
import csv

input = csv.DictReader(sys.stdin, delimiter=',')
for row in input:
	# Ausgabe beginnt mit der Klassifizierung:
	# hat gekauft (1), hat nicht gekauft (0) oder unbekannt (0.5)
	output = '0.5'
	if row['repeater'] == 't':
		output = '1'
	elif row['repeater'] == 'f':
		output = '0'

	# Customer ID eintragen und Feature-Liste beginnen
	output += ' \'' + row['id'] + ' |f'

	# Spalten in Features übersetzen
	for key in row:
		if key != 'id' and  key != 'repeater' and len(row[key]) > 0:
			output += ' ' + key + ':' + row[key]

	print(output)
\end{lstlisting}

\section{vw-preds-to-csv.py}
\label{code:vw-preds-to-csv}
\begin{lstlisting}[language=Python]
#!/usr/bin/env python

import sys

# Das Ergebnis von Vorpal Wabbit gibt ein Paar aus 
# Wahrscheinlichkeit und Kunden-ID pro Zeile und durch ein
# Leerzeichen getrennt aus.
# Dieses Programm konviertiert diese Format in da von Kaggle
# geforderte CSV-Format.

print('id,repeatProbability')

for line in sys.stdin:
	prob, id = line.split(' ', 1)
	print(id[:-1] + ',' + prob)
\end{lstlisting}
	
	